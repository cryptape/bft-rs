commit 266952ae342a4cd0ea2ec2e137ffab5843d69369
Author: rev-chaos <wancencen@cryptape.com>
Date:   Mon Apr 29 17:41:45 2019 +0800

    recover proposals add filter

diff --git a/src/collectors.rs b/src/collectors.rs
index 4818970..0a2ccee 100644
--- a/src/collectors.rs
+++ b/src/collectors.rs
@@ -3,6 +3,7 @@ use crate::{Address, Hash, Height, Round};
 
 use std::collections::HashMap;
 
+use crate::error::{BftError, BftResult};
 use lru_cache::LruCache;
 
 pub(crate) const CACHE_N: u64 = 16;
@@ -242,7 +243,7 @@ impl ProposalCollector {
         }
     }
 
-    pub(crate) fn add(&mut self, signed_proposal: &SignedProposal) {
+    pub(crate) fn add(&mut self, signed_proposal: &SignedProposal) -> BftResult<()>  {
         let proposal = &signed_proposal.proposal;
         let height = proposal.height;
         let round = proposal.round;
@@ -250,12 +251,13 @@ impl ProposalCollector {
             self.proposals
                 .get_mut(&height)
                 .unwrap()
-                .add(round, signed_proposal)
+                .add(round, signed_proposal)?
         } else {
             let mut round_proposals = ProposalRoundCollector::new();
-            round_proposals.add(round, signed_proposal);
+            round_proposals.add(round, signed_proposal)?;
             self.proposals.insert(height, round_proposals);
         }
+        Ok(())
     }
 
     pub(crate) fn get_proposal(&mut self, height: Height, round: Round) -> Option<SignedProposal> {
@@ -277,11 +279,12 @@ impl ProposalRoundCollector {
         }
     }
 
-    pub(crate) fn add(&mut self, round: Round, signed_proposal: &SignedProposal) {
+    pub(crate) fn add(&mut self, round: Round, signed_proposal: &SignedProposal) -> BftResult<()> {
         if self.round_proposals.contains_key(&round) {
-            return;
+            return Err(BftError::RecvMsgAgain(format!("{:?}", signed_proposal)));
         }
         self.round_proposals.insert(round, signed_proposal.clone());
+        Ok(())
     }
 
     pub(crate) fn get_proposal(&mut self, round: Round) -> Option<SignedProposal> {
diff --git a/src/error.rs b/src/error.rs
index 46e2f8e..83a3d95 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -8,6 +8,8 @@ pub enum BftError {
     /// Receive message error.
     RecvMsgErr(String),
 
+    RecvMsgAgain(String),
+
     ObsoleteMsg(String),
 
     HigherMsg(String),
@@ -44,7 +46,8 @@ pub(crate) fn handle_error<T>(result: BftResult<T>) {
         match e {
             BftError::NotReady(_)
             | BftError::ObsoleteMsg(_)
-            | BftError::HigherMsg(_) => trace!("Bft encounters {:?}", e),
+            | BftError::HigherMsg(_)
+            | BftError::RecvMsgAgain(_) => trace!("Bft encounters {:?}", e),
 
             BftError::CheckProofFailed(_)
             | BftError::CheckBlockFailed(_)
diff --git a/src/utils.rs b/src/utils.rs
index 0a08ffd..fa58aa3 100644
--- a/src/utils.rs
+++ b/src/utils.rs
@@ -328,7 +328,7 @@ where
         // prevent too many higher proposals flush out current proposal
         // because self.height - 1 is allowed, so judge height < self.height + CACHE_N - 1
         if height < self.height + CACHE_N - 1 && round < self.round + CACHE_N {
-            self.proposals.add(&signed_proposal);
+            self.proposals.add(&signed_proposal)?;
             if need_wal {
                 self.wal_log
                     .save(height, LogType::Proposal, &rlp::encode(signed_proposal))

commit d49b83a4af1bc80fca65a51b27b396a6ba8c0cd3
Author: rev-chaos <wancencen@cryptape.com>
Date:   Mon Apr 29 17:04:39 2019 +0800

    add timeout_info send error handle

diff --git a/src/timer.rs b/src/timer.rs
index f526b62..f7abe81 100644
--- a/src/timer.rs
+++ b/src/timer.rs
@@ -96,12 +96,12 @@ impl WaitTimer {
 
             if !timer_heap.is_empty() {
                 let now = Instant::now();
-
+                let info = timeout_info.remove(&timer_heap.pop_min().unwrap()).unwrap();
                 // if some timers are set as the same time, send timeout messages and pop them
                 while !timer_heap.is_empty() && now >= timer_heap.peek_min().cloned().unwrap() {
-                    self.timer_notify
-                        .send(timeout_info.remove(&timer_heap.pop_min().unwrap()).unwrap())
-                        .unwrap();
+                    if let Err(e) = self.timer_notify.send(info.clone()) {
+                        error!("timer_notify send {:?} error {:?}", info, e);
+                    }
                 }
             }
         }
diff --git a/src/utils.rs b/src/utils.rs
index 4f06659..0a08ffd 100644
--- a/src/utils.rs
+++ b/src/utils.rs
@@ -216,14 +216,16 @@ where
     #[inline]
     pub(crate) fn set_timer(&self, duration: Duration, step: Step) {
         info!("Bft sets {:?} timer for {:?}", step, duration);
-        self.timer_seter
-            .send(TimeoutInfo {
-                timeval: Instant::now() + duration,
-                height: self.height,
-                round: self.round,
-                step,
-            })
-            .unwrap();
+        let info = TimeoutInfo {
+            timeval: Instant::now() + duration,
+            height: self.height,
+            round: self.round,
+            step,
+        };
+        if let Err(e) = self.timer_seter
+            .send(info){
+            error!("processor send timeout_info error {:?}", e);
+        }
     }
 
     pub(crate) fn generate_proof(&mut self, lock_status: LockStatus) -> Proof {

commit a63aadcefaadec3773a5ec4cf865b8b67076b0c8
Author: rev-chaos <wancencen@cryptape.com>
Date:   Mon Apr 29 16:22:57 2019 +0800

    fix a bug of when receiving repeat proposal and return

diff --git a/src/collectors.rs b/src/collectors.rs
index 84377bf..4818970 100644
--- a/src/collectors.rs
+++ b/src/collectors.rs
@@ -3,7 +3,6 @@ use crate::{Address, Hash, Height, Round};
 
 use std::collections::HashMap;
 
-use crate::error::{BftError, BftResult};
 use lru_cache::LruCache;
 
 pub(crate) const CACHE_N: u64 = 16;
@@ -243,7 +242,7 @@ impl ProposalCollector {
         }
     }
 
-    pub(crate) fn add(&mut self, signed_proposal: &SignedProposal) -> BftResult<()> {
+    pub(crate) fn add(&mut self, signed_proposal: &SignedProposal) {
         let proposal = &signed_proposal.proposal;
         let height = proposal.height;
         let round = proposal.round;
@@ -251,13 +250,12 @@ impl ProposalCollector {
             self.proposals
                 .get_mut(&height)
                 .unwrap()
-                .add(round, signed_proposal)?
+                .add(round, signed_proposal)
         } else {
             let mut round_proposals = ProposalRoundCollector::new();
-            round_proposals.add(round, signed_proposal)?;
+            round_proposals.add(round, signed_proposal);
             self.proposals.insert(height, round_proposals);
         }
-        Ok(())
     }
 
     pub(crate) fn get_proposal(&mut self, height: Height, round: Round) -> Option<SignedProposal> {
@@ -279,12 +277,11 @@ impl ProposalRoundCollector {
         }
     }
 
-    pub(crate) fn add(&mut self, round: Round, signed_proposal: &SignedProposal) -> BftResult<()> {
+    pub(crate) fn add(&mut self, round: Round, signed_proposal: &SignedProposal) {
         if self.round_proposals.contains_key(&round) {
-            return Err(BftError::RecvMsgAgain(format!("{:?}", signed_proposal)));
+            return;
         }
         self.round_proposals.insert(round, signed_proposal.clone());
-        Ok(())
     }
 
     pub(crate) fn get_proposal(&mut self, round: Round) -> Option<SignedProposal> {
diff --git a/src/error.rs b/src/error.rs
index 83a3d95..46e2f8e 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -8,8 +8,6 @@ pub enum BftError {
     /// Receive message error.
     RecvMsgErr(String),
 
-    RecvMsgAgain(String),
-
     ObsoleteMsg(String),
 
     HigherMsg(String),
@@ -46,8 +44,7 @@ pub(crate) fn handle_error<T>(result: BftResult<T>) {
         match e {
             BftError::NotReady(_)
             | BftError::ObsoleteMsg(_)
-            | BftError::HigherMsg(_)
-            | BftError::RecvMsgAgain(_) => trace!("Bft encounters {:?}", e),
+            | BftError::HigherMsg(_) => trace!("Bft encounters {:?}", e),
 
             BftError::CheckProofFailed(_)
             | BftError::CheckBlockFailed(_)
diff --git a/src/utils.rs b/src/utils.rs
index 10e5a44..4f06659 100644
--- a/src/utils.rs
+++ b/src/utils.rs
@@ -326,7 +326,7 @@ where
         // prevent too many higher proposals flush out current proposal
         // because self.height - 1 is allowed, so judge height < self.height + CACHE_N - 1
         if height < self.height + CACHE_N - 1 && round < self.round + CACHE_N {
-            self.proposals.add(&signed_proposal)?;
+            self.proposals.add(&signed_proposal);
             if need_wal {
                 self.wal_log
                     .save(height, LogType::Proposal, &rlp::encode(signed_proposal))

commit f649bb08dc9de53a644a87db5e9abee69328cbce
Author: rev-chaos <wancencen@cryptape.com>
Date:   Mon Apr 29 15:00:08 2019 +0800

    add infos

diff --git a/src/algorithm.rs b/src/algorithm.rs
index 3bb5f12..9186a4d 100644
--- a/src/algorithm.rs
+++ b/src/algorithm.rs
@@ -175,7 +175,6 @@ where
                     let signed_vote: SignedVote = rlp::decode(&encode).map_err(|e| {
                         BftError::DecodeErr(format!("signed_vote encounters {:?}", e))
                     })?;
-                    trace!("Bft receives {:?}", &encode);
                     self.check_and_save_vote(&signed_vote, need_wal)?;
 
                     let vote = signed_vote.vote;
diff --git a/src/utils.rs b/src/utils.rs
index 6586cd0..10e5a44 100644
--- a/src/utils.rs
+++ b/src/utils.rs
@@ -299,6 +299,7 @@ where
         encode: &Encode,
         need_wal: bool,
     ) -> BftResult<()> {
+        info!("Bft receives {:?}", signed_proposal);
         let proposal = &signed_proposal.proposal;
         let height = proposal.height;
         let round = proposal.round;
@@ -355,6 +356,7 @@ where
         signed_vote: &SignedVote,
         need_wal: bool,
     ) -> BftResult<()> {
+        info!("Bft receives {:?}", signed_vote);
         let vote = &signed_vote.vote;
         let height = vote.height;
         let round = vote.round;

commit 38f105d0de303cebe1c6c37dcb3f108204dcc099
Author: rev-chaos <wancencen@cryptape.com>
Date:   Mon Apr 29 12:37:09 2019 +0800

    change some traces to infos

diff --git a/src/algorithm.rs b/src/algorithm.rs
index 0c977c1..3bb5f12 100644
--- a/src/algorithm.rs
+++ b/src/algorithm.rs
@@ -362,13 +362,9 @@ where
     }
 
     fn handle_vote(&mut self, vote: Vote) -> BftResult<()> {
-        trace!(
+        info!(
             "Bft handles a {:?} vote of height {:?}, round {:?}, to {:?}, from {:?}",
-            vote.vote_type,
-            vote.height,
-            vote.round,
-            vote.block_hash,
-            vote.voter
+            vote.vote_type, vote.height, vote.round, vote.block_hash, vote.voter
         );
 
         if vote.height == self.height - 1 {
@@ -509,7 +505,7 @@ where
             self.new_round_start(true)?;
             self.flush_cache()?;
 
-            trace!(
+            info!(
                 "Bft receives rich status, goto new height {:?}",
                 status.height + 1
             );
@@ -541,7 +537,7 @@ where
 
         let msg = if self.lock_status.is_some() {
             // if is locked, boradcast the lock proposal
-            trace!("Bft is ready to transmit locked Proposal");
+            info!("Bft is ready to transmit locked Proposal");
             let lock_status = self.lock_status.clone().unwrap();
             let lock_round = lock_status.round;
             let lock_votes = lock_status.votes;
@@ -574,7 +570,7 @@ where
                 .expect("Have checked before, should not happen!");
             let block_hash = self.function.crypt_hash(&block);
             self.block_hash = Some(block_hash.clone());
-            trace!("Bft is ready to transmit new Proposal");
+            info!("Bft is ready to transmit new Proposal");
 
             let proposal = Proposal {
                 height: self.height,
@@ -589,10 +585,9 @@ where
             let signed_proposal = self.build_signed_proposal(&proposal)?;
             BftMsg::Proposal(rlp::encode(&signed_proposal))
         };
-        trace!(
+        info!(
             "Bft transmits proposal at height {:?}, round {:?}",
-            self.height,
-            self.round
+            self.height, self.round
         );
         self.function.transmit(msg.clone());
         self.send_bft_msg(msg)?;
@@ -608,10 +603,9 @@ where
             Vec::new()
         };
 
-        trace!(
+        info!(
             "Bft transmits prevote at height {:?}, round {:?}",
-            self.height,
-            self.round
+            self.height, self.round
         );
 
         let vote = Vote {
@@ -624,7 +618,7 @@ where
         let signed_vote = self.build_signed_vote(&vote)?;
         let msg = BftMsg::Vote(rlp::encode(&signed_vote));
 
-        trace!("Bft prevotes to {:?}", block_hash);
+        info!("Bft prevotes to {:?}", block_hash);
         self.function.transmit(msg.clone());
         self.send_bft_msg(msg)?;
 
@@ -646,10 +640,9 @@ where
             Vec::new()
         };
 
-        trace!(
+        info!(
             "Bft transmits precommit at height {:?}, round {:?}",
-            self.height,
-            self.round
+            self.height, self.round
         );
 
         let vote = Vote {
@@ -662,7 +655,7 @@ where
         let signed_vote = self.build_signed_vote(&vote)?;
         let msg = BftMsg::Vote(rlp::encode(&signed_vote));
 
-        trace!("Bft precommits to {:?}", block_hash);
+        info!("Bft precommits to {:?}", block_hash);
         self.function.transmit(msg.clone());
         self.send_bft_msg(msg)?;
 
@@ -674,13 +667,13 @@ where
     }
 
     fn retransmit_lower_votes(&self, round: u64) -> BftResult<()> {
-        trace!(
+        info!(
             "Bft finds some nodes are at low height, retransmit votes of height {:?}, round {:?}",
             self.height - 1,
             round
         );
 
-        trace!(
+        info!(
             "Bft retransmits votes to proposal {:?}",
             self.last_commit_block_hash.clone().unwrap()
         );
@@ -719,7 +712,7 @@ where
         };
         let signed_precommit = self.build_signed_vote(&precommit)?;
 
-        trace!("Bft finds some nodes fall behind, and sends nil vote to help them pursue");
+        info!("Bft finds some nodes fall behind, and sends nil vote to help them pursue");
         self.function
             .transmit(BftMsg::Vote(rlp::encode(&signed_precommit)));
         Ok(())
@@ -727,10 +720,9 @@ where
 
     fn new_round_start(&mut self, new_round: bool) -> BftResult<()> {
         if self.step != Step::ProposeWait {
-            trace!(
+            info!(
                 "Bft starts height {:?}, round {:?}",
-                self.height,
-                self.round
+                self.height, self.round
             );
         }
         self.change_to_step(Step::ProposeWait);
@@ -790,18 +782,15 @@ where
 
     fn is_proposer(&self) -> BftResult<bool> {
         let proposer = self.get_proposer(self.height, self.round)?;
-        trace!(
+        info!(
             "Bft chooses proposer {:?} at height {}, round {}",
-            proposer,
-            self.height,
-            self.round
+            proposer, self.height, self.round
         );
 
         if self.params.address == *proposer {
-            trace!(
+            info!(
                 "Bft becomes proposer at height {}, round {}",
-                self.height,
-                self.round
+                self.height, self.round
             );
             return Ok(true);
         }
@@ -828,7 +817,7 @@ where
                 || self.lock_status.clone().unwrap().round <= proposal.lock_round.unwrap())
         {
             // receive a proposal with a later PoLC
-            trace!(
+            info!(
                     "Bft handles a proposal with the PoLC that proposal is {:?}, lock round is {:?}, lock votes are {:?}",
                     block_hash,
                     proposal.lock_round,
@@ -851,13 +840,13 @@ where
             && proposal.round == self.round
         {
             // receive a proposal without PoLC
-            trace!(
+            info!(
                 "Bft handles a proposal without PoLC, the proposal is {:?}",
                 block_hash
             );
             self.block_hash = Some(block_hash);
         } else {
-            trace!("Bft handles a proposal with an earlier PoLC");
+            info!("Bft handles a proposal with an earlier PoLC");
             return;
         }
     }
@@ -876,10 +865,9 @@ where
         if !flag {
             return false;
         }
-        trace!(
+        info!(
             "Bft collects over 2/3 prevotes at height {:?}, round {:?}",
-            self.height,
-            self.round
+            self.height, self.round
         );
 
         if let Some(prevote_set) =
@@ -899,10 +887,9 @@ where
                     {
                         if hash.is_empty() {
                             // receive +2/3 prevote to nil, clean lock info
-                            trace!(
+                            info!(
                                 "Bft collects over 2/3 prevotes to nil at height {:?}, round {:?}",
-                                self.height,
-                                self.round
+                                self.height, self.round
                             );
                             self.clean_polc();
                             self.block_hash = None;
@@ -941,16 +928,15 @@ where
                 return PrecommitRes::Below;
             }
 
-            trace!(
+            info!(
                 "Bft collects over 2/3 precommits at height {:?}, round {:?}",
-                self.height,
-                self.round
+                self.height, self.round
             );
 
             for (hash, count) in &precommit_set.votes_by_proposal {
                 if self.cal_above_threshold(*count) {
                     if hash.is_empty() {
-                        trace!(
+                        info!(
                             "Bft reaches nil consensus, goto next round {:?}",
                             self.round + 1
                         );
diff --git a/src/utils.rs b/src/utils.rs
index 12f3ab0..6586cd0 100644
--- a/src/utils.rs
+++ b/src/utils.rs
@@ -35,41 +35,41 @@ where
     fn process_wal_log(&mut self, log_type: LogType, encode: Vec<u8>) -> BftResult<()> {
         match log_type {
             LogType::Proposal => {
-                trace!("Load proposal");
+                info!("Load proposal");
                 self.process(BftMsg::Proposal(encode), false)?;
             }
             LogType::Vote => {
-                trace!("Load vote");
+                info!("Load vote");
                 self.process(BftMsg::Vote(encode), false)?;
             }
             LogType::Feed => {
-                trace!("Load feed");
+                info!("Load feed");
                 let feed: Feed = rlp::decode(&encode)
                     .map_err(|e| BftError::DecodeErr(format!("feed encounters {:?}", e)))?;
                 self.process(BftMsg::Feed(feed), false)?;
             }
             LogType::Status => {
-                trace!("Load status");
+                info!("Load status");
                 let status: Status = rlp::decode(&encode)
                     .map_err(|e| BftError::DecodeErr(format!("status encounters {:?}", e)))?;
                 self.process(BftMsg::Status(status), false)?;
             }
             LogType::Proof => {
-                trace!("Load proof");
+                info!("Load proof");
                 let proof: Proof = rlp::decode(&encode)
                     .map_err(|e| BftError::DecodeErr(format!("proof encounters {:?}", e)))?;
                 self.proof = proof;
             }
             #[cfg(feature = "verify_req")]
             LogType::VerifyResp => {
-                trace!("Load verify_resp");
+                info!("Load verify_resp");
                 let verify_resp: VerifyResp = rlp::decode(&encode)
                     .map_err(|e| BftError::DecodeErr(format!("verify_resp encounters {:?}", e)))?;
                 self.process(BftMsg::VerifyResp(verify_resp), false)?;
             }
 
             LogType::TimeOutInfo => {
-                trace!("Load time_out_info");
+                info!("Load time_out_info");
                 let time_out_info: TimeoutInfo = rlp::decode(&encode).map_err(|e| {
                     BftError::DecodeErr(format!("time_out_info encounters {:?}", e))
                 })?;
@@ -165,26 +165,26 @@ where
     pub(crate) fn set_status(&mut self, status: &Status) {
         self.authority_manage
             .receive_authorities_list(status.height, status.authority_list.clone());
-        trace!("Bft updates authority_manage {:?}", self.authority_manage);
+        info!("Bft updates authority_manage {:?}", self.authority_manage);
 
         if self.consensus_power
             && !status
-            .authority_list
-            .iter()
-            .any(|node| node.address == self.params.address)
+                .authority_list
+                .iter()
+                .any(|node| node.address == self.params.address)
         {
-            trace!(
+            info!(
                 "Bft loses consensus power in height {} and stops the bft-rs process!",
                 status.height
             );
             self.consensus_power = false;
         } else if !self.consensus_power
             && status
-            .authority_list
-            .iter()
-            .any(|node| node.address == self.params.address)
+                .authority_list
+                .iter()
+                .any(|node| node.address == self.params.address)
         {
-            trace!(
+            info!(
                 "Bft accesses consensus power in height {} and starts the bft-rs process!",
                 status.height
             );
@@ -205,7 +205,7 @@ where
             votes: voteset.extract_polc(hash),
         });
 
-        trace!(
+        info!(
             "Bft sets a PoLC at height {:?}, round {:?}, on proposal {:?}",
             self.height,
             self.round,
@@ -215,7 +215,7 @@ where
 
     #[inline]
     pub(crate) fn set_timer(&self, duration: Duration, step: Step) {
-        trace!("Bft sets {:?} timer for {:?}", step, duration);
+        info!("Bft sets {:?} timer for {:?}", step, duration);
         self.timer_seter
             .send(TimeoutInfo {
                 timeval: Instant::now() + duration,
@@ -815,10 +815,9 @@ where
     pub(crate) fn clean_polc(&mut self) {
         self.block_hash = None;
         self.lock_status = None;
-        trace!(
+        info!(
             "Bft cleans PoLC at height {:?}, round {:?}",
-            self.height,
-            self.round
+            self.height, self.round
         );
     }
 
@@ -830,7 +829,7 @@ where
         self.votes.clear_prevote_count();
 
         #[cfg(feature = "verify_req")]
-            self.verify_results.clear();
+        self.verify_results.clear();
     }
 
     #[inline]
